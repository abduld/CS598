\section{Motivation and Overview}
Heterogeneous computing promises to address the rising power dissipation problem
of today's traditional, homogeneous multi-core
systems. It provides the ability to integrate a variety of processing elements,
such as large and small general purpose cores, GPUs, DSPs, and custom or
semi-custom hardware into a single system. If applications can efficiently use
the full range of available hardware, it can provide significant energy
savings over conventional processors by executing portions of the code on the
device which best suits it. This has led mobile devices such as smartphones
and tablets, which deal with a variety of applications with limited battery
life, to move towards heterogeneous designs.

However, heterogenity of hardware resouces also has led to a diverse landscape
of different programming models, run-time systems, profiling and debugging tools
for application development. The differences are so deep that programmers are
often experts on only one class of device, e.g., an expert GPU programmer will
not have much DSP expertise and vice-versa. This is highly inefficient and
unproductive: we cannot expect applications to use a separate language for each
class of compute unit. If we want applications to use the full range of
available hardware to maximize perofrmance or energy efficiency or both, the
programming environment has to provide common abstractions for available
hardware compute units.

The industry and the research community have been trying to solve this problem.
The recent development of Renderscript~\cite{Renderscript} provides a framework
for running computationally intensive tasks at a high performance by using a
specialized runtime for 
parallelizing work across all processors available on the device, such as
multi-core CPUs, GPUs, or DSPs. So renderscript is essentially removing the
burden of load balancing from the programmer to the run-time, unlike other
solutions such as OpenCL, where the programmer has more control over the
execution semantics of the application ({\em the programmer decides which part
of application would run on which device}). In this fashion renderscript is
making the computationally intensive part of the applcation, that needs to be
accerated on specialized hardware, portable across the various hardware compute
units. Also, since the application is not dependent on the existence and
availablity of a specific accelerator, the application is portable across SoCs
with different combinations of compue units.

While such portability is a fine goal, Renderscript achieves it at the cost of
hiding hardware details from the programmer that are critical to good
performance on these accelerator. For example, in GPUs, the placement of data at
various levels of memory hierarchy is critical to good performance on them.
It is this reason that most programming languages for GPUs, allow the programmer
limited control over memory management. Renderscript too uses GPUs for acceleration, but
completely hides the memory management from the programmer. In the Renderscript
model, application developers only define the part of the application that needs
to be accelerated, and the granularity at which data needs to be partitioned,
while the rest of the responsibilities of memory management and work distribution
among different compute units is handled by Renderscript compiler and run-time.
This raises an important
question of ``how effective is the Renderscript compiler and run-time?'', which
we plan to answer by doing a comprehensive performance analysis of Renderscript.
