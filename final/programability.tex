\subsection{RenderScript Programmability}
This section presents our analysis of RenderScript's programmability --- how
comfortable we, as programmers, feel when working with RenderScript. Since this
analysis is primarily based on our experience working with RenderScript
throughout this semester, it is highly subjective. Additionally, we are aware
that some of the limitations presented in this section are due to the fact that
RenderScript is a new framework, which is being rapidly developed and deployed.
Therefore, we expect that RenderScript will keep evolving to close many of the
identified limitations.

\paragraph{The Goods.}
We start by describing the features that we like about the RenderScript.

\textit{RenderScript delivers on its promises about code portability}.
The runtime behavior of our RenderScript implementations is consistent across
five different tested devices and seven different benchmarks. For example, we
always got the same runtime errors, e.g., segmentation fault or out-of-memory
error, regardless of the devices that the code is running on. Furthermore, we
did not have to express any device specific parameters in our code. The code
portability gives us a confidence that if a kernel works on our testing device,
it will work seamlessly on other devices. OpenCL, on the other hand, required
tuning some
parameters, such as work-group sizes, in order to avoid crashes when ported to
other devices.

\textit{Debugging RenderScript code is convenient}. Since RenderScript is
natively supported in Android, it offers a set of convenient built-in debugging
facilities, such as the \fix{rsDebug()} functions, detailed runtime exceptions,
and IDE-navigable compilation errors. The \fix{rsDebug()} functions in
RenderScript runtime API provide a familiar debugging interface for displaying
runtime information inside RenderScript kernels. Since most programmers are accustomed
to \fix{printf()} debugging style in C/C++, this interface provides exactly
what we need for debugging. Note that it is not convenient to use the
\fix{printf()} debugging style in other host/device programming models, such as
OpenCL and CUDA, since it is available only in emulation mode.

\textit{The \fix{Allocation} interface is intuitive to express data and
execution parallelism}. As described in section~\ref{sec:imple_RS}, this
\fix{Allocation} interface allows explicitly expressing parallelism
granularities, i.e., via packing output and/or input into \fix{Element} objects,
for RenderScript kernels.  We quickly got used to this interface
after completing the first set of simple benchmarks, and we did not encounter
any problems using this interface.

\textit{Writing RenderScript kernel in C99 brings great flexibility and
performability\todo{Is this a word? What do you mean by performability}}. We
liked the feeling of having complete control when using
the C language for performance critical code. We understand that this point is
completely biased due to our proficiency with C, C++, and CUDA. For many
programmers, it is an abrupt transition from programming in Java to programming
in C.

%\textit{Active community}. stackoverflow response time was good and the answers
%were useful.

\paragraph{The Bads.} We also found that RenderScript was still unpleasant to
work with as it has some unnecessary idiosyncratic restrictions. However, many
of these limitations exist due to the
infancy of the framework.

\textit{No intrinsic synchronization within kernels.} Currently, RenderScript
only allows global synchronization by calling the \fix{syncAll()} function in
Java host code. This means that there is no CUDA-like \fix{\_\_syncthread()} or
OpenCL-like \fix{barrier()} functions that can be called inside RenderScript
kernels. Therefore, RenderScript kernels do not allow threads to share
intermediate data. We found that this model is too restrictive in several
scenarios. For example in the \fix{CUTCP} benchmark, we had to substantially
modify the RenderScript \todo{Do you mean OpenCL implementation} implementation in order
to overcome the lack of
synchronization support.

\textit{Lack of support for multi-dimensional parallelism}. A RenderScript
kernel allows an \fix{Allocation} to specify \fix{X}, \fix{Y}, and \fix{Z}
dimensions, and the workload would be distributed across hardware units using
these dimensions. However, currently it only supports two
dimensions. The interface for the third dimension exists but was not
implemented.

\textit{Overhead of data transfer}. Before RenderScript execution starts, all
heap data to be used by the RenderScript kernel has to copied into one or more
\fix{Allocation} type. Data has to be copied back from \fix{Allocation} after
RenderScript execution. These data copies can be avoided when a kernel is
executing in the same
coherence domain. However, the current implementation of RenderScript does not
perform these optimizations.

\textit{Lack of documentation and standardization.} RenderScript was released recently in 2011 and we found the current documentation to be insufficient. For instance, atomic instructions such as \fix{rsAtomicInc(<Type>)} are claimed to exist in documentation and RenderScript header files for several data types, but the RenderScript runtime had support for only \fix{int32\_t} data type.


