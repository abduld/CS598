\subsection{RenderScript Programmability}
This section presents our analysis of RenderScript's programmability --- how
comfortable we, as programmers, feel when working with RenderScript. Since this
analysis is primarily based on our experience working with RenderScript
throughout this semester, it is highly subjective. Additionally, we are aware
that some of the limitations presented in this section are due to the fact that
RenderScript is a new framework, which is being rapidly developed and deployed.
Therefore, we expect that RenderScript will keep evolving to close many of the
identified limitations.

\paragraph{The Goods.}
We start by describing the features that we like about the RenderScript.

\textit{RenderScript delivers on its promises about code portability}.
The runtime behavior of our RenderScript implementations is consistent across
five different tested devices and seven different benchmarks. For example, we
always got the same runtime errors, e.g., segmentation fault or out-of-memory
error, regardless of the devices that the code is running on. Furthermore, we
did not have to express any device specific parameters in our code. The code
portability gives us a confidence that if a kernel works on our testing device,
it will work seamlessly on other devices. OpenCL, on the other hand, required
tuning some
parameters, such as work-group sizes, in order to avoid crashes when ported to
other devices.

\subsubsection{Debug Support}

Since RenderScript is natively supported in Android,
it offers a set of convenient built-in debugging
facilities, such as the \fix{rsDebug()} functions, detailed runtime exceptions,
and IDE-navigable compilation errors.
The \fix{rsDebug()} function forces RenderScript to execute on the CPU and interacts 
with the eclipse platform to offer a convinent way to present printed values from within the kernel
(OpenCL and CUDA offer similar facilities, but they are less convinent to use).
For programmers accustomed to \fix{printf()} debugging style in C/C++, this interface provides
a familiar debugging model. For developers expecting a breakpoint debugging workflow, the eclipse
environment has no facilities for that currently.


\subsubsection{Memory Operations}

The \fix{Allocation} interface is intuitive to express data and
execution parallelism}. As described in section~\ref{sec:imple_RS}, this
\fix{Allocation} interface allows explicitly expressing parallelism
granularities, i.e., via packing output and/or input into \fix{Element} objects,
for RenderScript kernels.  We quickly got used to this interface
after completing the first set of simple benchmarks, and we did not encounter
any problems using this interface.

Within the kernel, utility functions (\fix{rsGetElementAt_*}) make indexing
 into a multi-dimensional arrays platform agnostic
 (e.g. the strides should not be assumed to be the same across architectures).


\subsubsection{Familiar Language}

\textit{Writing RenderScript kernel in C99 brings great flexibility and
performability\todo{Is this a word? What do you mean by performability}}. We
liked the feeling of having complete control when using
the C language for performance critical code. We understand that this point is
completely biased due to our proficiency with C, C++, and CUDA. For many
programmers, it is an abrupt transition from programming in Java to programming
in C.

\paragraph{The Bads.} We also found that RenderScript was still unpleasant to
work with as it has some unnecessary idiosyncratic restrictions. However, many
of these limitations exist due to the
infancy of the framework.

\subsubsection{Lack of Intrinsics}

\textit{No intrinsic synchronization within kernels.} Currently, RenderScript
only allows global synchronization by calling the \fix{syncAll()} function in
Java host code. This means that there is no CUDA-like \fix{\_\_syncthread()} or
OpenCL-like \fix{barrier()} functions that can be called inside RenderScript
kernels. Therefore, RenderScript kernels do not allow threads to share
intermediate data. We found that this model is too restrictive in several
scenarios. For example in the \fix{CUTCP} benchmark, we had to substantially
modify the RenderScript \todo{Do you mean OpenCL implementation} implementation in order
to overcome the lack of
synchronization support.

\subsubsection{Multi-Dimensional Parallelism}


\textit{Lack of support for multi-dimensional parallelism}. A RenderScript
kernel allows an \fix{Allocation} to specify \fix{X}, \fix{Y}, and \fix{Z}
dimensions, and the workload would be distributed across hardware units using
these dimensions. However, currently it only supports two
dimensions. The interface for the third dimension exists but was not
implemented.

\subsubsection{Non-Unified Memory}

Before RenderScript execution starts, all
heap data to be used by the kernel has to copied into \fix{Allocation} buffers.
The buffer has to be copied back to make it available to Java.
Safe casting between Java and C requires some checking --- since Java does not 
  conform to the same IEEE standard that RenderScript conforms to.
But in the case of unsafe copies, these can be avoided when the kernel is
  executing in the same coherence domain.
The current implementation of RenderScript does not perform these optimizations.
Furthermore, the runtime, via function overloading, should be able to hide 
  explicit buffer creation and copies, by detecting the type passed into the function
  and converting to a \fix{Allocation} buffer if what is passed is a Java array.

\subsubsection{Lack of a Standardization}

RenderScript is similar to CUDA in this respect --- the reference implementation
  is the standard.
Yet unlike CUDA, RenderScript's documentation tend to be incomplete and insufficient.
Atomic instructions such as \fix{rsAtomicInc(<Type>)}, for example, are claimed to be supported
in documentation and appear in the header files for several data types, but upon usage 
the runtime raises an exception if any type other than \fix{int32\_t} is used.
The lack of specification results in some errors being unintuitive --- one has to 
  read the runtime to determine what the error refers to and what caused it.
It also means that it is unlikely that RenderScript would be 
  ported to desktop platforms.


\subsubsection{Another Parallel Framework}

Aside from having full control over the language, it is not clear why
 Google did not adopt OpenCL or OpenCL's SPIR layer.
As can be seen, the RenderScript language borrows many elements from the CUDA/OpenCL 
 programming model, with some tooling support.
Many of the ``features'' of RenderScript can be implementing via a library that 
 interacts with OpenCL and there is no need for a new language.
One reason could be that the compiler and runtime can prevent compute code that run on the GPU from
 possibly crashing the driver (by using too much resources or using unsafe memory accesses),
 since crashing the GPU driver on mobile devices is equivalent to crashing the device.
Yet, again, this feature can be implemented by enhancing the OpenCL compiler and runtime to detect
 and raise an exception if illegal memory accesses occur.

