\subsection{RenderScript Programmability}
This section presents our analysis of RenderScript's programmability --- how
comfortable we, as programmers, feel when working with RenderScript. Since this
analysis is primarily based on our experience working with RenderScript
throughout this semester, it is subjective. Furthermore, we are fully aware of
that some of the limitations presented in this section are due to the fact that
RenderScript is a new framework being rapidly developed and deployed.
Therefore, we expect that RenderScript will keep evolving to close most of the
identified limitations.

\paragraph{The Goods.}
We start by describing the features that we like about the RenderScript
programming model.

\textit{RenderScript delivers its promises about the code portability}.
The runtime behavior of our RenderScript implementations is consistent across
five different tested devices and seven different benchmarks. For example, we
always got the same runtime errors, e.g., segmentation fault or out-of-memory
error, regardless of the devices that the code is running on. Furthermore, we
did not have to express any device specific parameters in our code. The code
portability gives us a confidence that if a kernel works on our testing device,
it will work seamlessly on other devices. Unlike OpenCL, we needed to tune some
parameters, such as the thread block sizes, in order to avoid crashes in some
devices.

\textit{Debugging in RenderScript is convenient}. Since RenderScript is natively
supported in Android, it offers a set of convenient built-in debugging
facilities, such as the \fix{rsDebug()} functions, detailed runtime exceptions,
and IDE-navigable compilation errors. The \fix{rsDebug()} functions in
RenderScript's runtime API provide a familiar debugging interface for displaying
runtime information inside RenderSript kernels. Since most programmers accustom
to the \fix{printf()} debugging style in C/C++, this interface provides exactly
what we need for debugging. Note that it is not convenient to use the
\fix{printf()} debugging style in other host/device programming models, such as
OpenCL and CUDA, since it is available only in emulation mode.

\textit{The \fix{Allocation} interface is intuitive to express data and
execution parallelism}. As described in section~\ref{sec:imple_RS}, this
\fix{Allocation} interface allows explicitly expressing parallelism
granularities, i.e., via packing output and/or input into \fix{Element} objects,
for RenderScript kernels.  We quickly accustomed to this interface
after completing the first few simple benchmarks, and we did not encounter
any problems using this interface.

\textit{Writing RenderScript kernel in C99 brings great flexibility and
performability}. We liked the feeling of having a complete control when using
the C language for performance critical code. We understand that this point is
completely biased due to our proficiency with C, C++, and CUDA. For many
programmers, it is an abrupt transition from programming in Java to programming
in C.

%\textit{Active community}. stackoverflow response time was good and the answers
%were useful.

\paragraph{The Bads.} We also found that RenderScript is still unpleasant to work
with in various aspects. We also note that many of these limitations due to the
infancy of the framework.

\textit{No intrinsic synchronization within kernels.}

\textit{Only support two coordinates.}

\textit{Overhead of data transfer}. Even a kernel is executed in the same
coherence domain.

\textit{Lack of documentation and standardization.} Example: kernel invocation generation.


