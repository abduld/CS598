
\section*{Methodology}

In our proposal we stated that if we were able to run OpenCL on the Android devices, then
  we will benchmark against OpenCL.
Sadly, we were not able to find a way to run OpenCL on the devices.
Instead, we opted to implement a serial version of the code in Java along with a multithreaded version
  and compare both against RenderScript.
This is added work, since we now impleemnt 3 versions of the same benchmark, but since we usually
  start with the serial Java version, make it multithreaded, and then port the multithreaded code
  into RenderScript.

All the implementations share a common interface, which means our framework takes the code,
  runs it, and the information is stored in a database on the device which we use for analysis.

\subsection*{Performance Analysis}

We tried to mirror some of the API decisions found in Parboil, this is the same for the timer code.
We implemented a class that allows us to time sections of code and store dump them into the database.

\begin{verbatim}
  timer.start("IO", "Reading inputs");
  float[] inputData = ReadVectorData("input.data");
  timer.stop();
\end{verbatim}

Unlike Parboil's timers however, our interface does not aggregate the data.
This is left for the analysis pass.
The reason is that we feal like Parboil looses some information about which sections are hot in the
  code by aggregating all the data for you.

\subsection*{Power Analysis}

Many hours were wasted trying to find a way to programatically read power data.
A way that may work in debug mode, but other than that it seems like every vendor offers their own
  counter and there is no unified Android API to measure how much power is being drawn at a 
  specific point in time.
